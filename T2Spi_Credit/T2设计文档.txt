设计说明文档
1、说明的setOrder之类的都是覆盖式Set，所以新建之后一定要先权衡其生命周期内的更新是不是全量更新(标准是需要)，如果不是，一定要先取，比如撤单回报中，一定要先
根据撤单编号去TradeData里去取整个结构体，然后赋值。而且考虑到恒生接口的极度不靠谱以及可能的变化因此，所有的一个Order被多处修改尽量使用先取再用。
详细说明如下(只记载增量更新)：
OnSendOrder(第一次初始化) 缺少成交数量,因此可以不先找  ->DealBSEntrustPush先找  ->
DealBSDealPush不查找每次都是第一次->结束不再查询委托单(先找，虽然全都有)

T2撤单流程：撤单应答->撤单委托推送->原委托的成交推送，其区分与下单产生的成交推送的地方在于real_type（标记成交类型）

2、初始化查询委托和成交，虽然成交下挂在委托下，但由于重载了=，因此成交先于委托到，并不会产生问题。
3、server端是以线程为单位管理ref_id的，等闲一点了一定要彻底吃透ref_id作用，并且加上撤单的部分,ref_id可以用来对同种类型的查询区分处理(因为查询可能要分批查询)，
比如第一次初始化和之后的查询处理方式是不同的，如果不用ref_id首先算法设计很复杂，其次很容易出错
4、有关撤单的时候如何更新中间状态
A撤单会产生委托类型为撤单的B，最终方案为在B的委托回报回来的时候查找原委托状态，根据原委托手动更改为对应的中间状态，由于委托回报一定先回来，并且如果不推成交，
手动查询的结果也是中间状态因此可行。
如果在B的委托回报回来的时候（只可能一次），触发针对A的委托查询来更改A的委托状态，无法处理A的查询比A的成交类型为撤单的成交推送
（更新委托A状态）先回来的情况，如果做不可逆检查，由于成交推送存在已撤、废单、已报三种情况，因此没办法进行处理已报。
未报没有经过报盘，直接在撤单应答里更改为已撤即可。原委托不会再有任何委托推送和成交推送，委托类型为撤单的新委托将会收到一笔成交推送，但是不会有任何委托推送。