设计说明文档
1、说明的setOrder之类的都是覆盖式Set，所以新建之后一定要先权衡其生命周期内的更新是不是全量更新(标准是需要)，如果不是，一定要先取，比如撤单回报中，一定要先
根据撤单编号去TradeData里去取整个结构体，然后赋值。而且考虑到恒生接口的极度不靠谱以及可能的变化因此，所有的一个Order被多处修改尽量使用先取再用。
详细说明如下(只记载增量更新)：
OnSendOrder(第一次初始化) 缺少成交数量,因此可以不先找  ->DealBSEntrustPush先找  ->
DealBSDealPush不查找每次都是第一次->结束不再查询委托单(先找，虽然全都有)



2、初始化查询委托和成交，虽然成交下挂在委托下，但由于重载了=，因此成交先于委托到，并不会产生问题。
3、server端是以线程为单位管理ref_id的，ref_id可以用来对同种类型的查询区分处理(因为查询可能要分批查询)，比如第一次初始化和之后的查询处理方式是不同的
4、有关撤单的时候如何更新中间状态

要撤A，将会通过333017下单，首先受到333017的应答，返还一个新委托单B,接下来将受到B的委托回报主推，如果可能的话将会受到委托单A的成交回报主推

T2撤单流程：撤单应答->撤单委托推送->原委托的成交推送，其区分与下单产生的成交推送的地方在于real_type（标记成交类型）

A撤单会产生委托类型为撤单的B，最终方案为首先在B的委托应答里查看A的委托状态，如果为未报，直接改为已撤，其他不处理，接着在B的委托回报主推里查找原委托状态，
根据原委托手动更改为对应的中间状态，最后在A的委托类型为委托，成交类型为撤单的成交回报主推里更新A的委托单状态
如果在B的委托回报主推回来的时候（只可能一次），触发针对A的委托查询来更改A的委托状态，无法处理A的查询比A的成交类型为撤单的成交推送
（更新委托A状态）先回来的情况，如果做不可逆检查，由于成交推送存在已撤、废单、已报三种情况，因此没办法进行处理已报。
普通交易：未报没有经过报盘，直接在撤单应答里更改为已撤即可，不会再有任何委托推送和成交推送。
融资融券：未报没有经过报盘，撤单应答里没有原委托状态，无法直接更改为已撤，但接下来会有原委托单的一笔没有委托类型，成交类型为撤单的成交推送，并在其中把它更改为已撤
委托推送改版之后只可能推送一次

暂时设置的为不支持多端登录